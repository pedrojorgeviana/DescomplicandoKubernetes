
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <title>Simplificando Kubernetes día 8 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.20">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../day-9/" />
    
    
    <link rel="prev" href="../day-7/" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Acerca de</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introducción
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Capítulos</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../day-1/">
            
                <a href="../day-1/">
            
                    
                    Simplificando Kubernetes día 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../day-2/">
            
                <a href="../day-2/">
            
                    
                    Simplificando Kubernetes día 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../day-3/">
            
                <a href="../day-3/">
            
                    
                    Simplificando Kubernetes día 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../day-4/">
            
                <a href="../day-4/">
            
                    
                    Simplificando Kubernetes día 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../day-5/">
            
                <a href="../day-5/">
            
                    
                    Simplificando Kubernetes día 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../day-6/">
            
                <a href="../day-6/">
            
                    
                    Simplificando Kubernetes día 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="../day-7/">
            
                <a href="../day-7/">
            
                    
                    Simplificando Kubernetes día 7
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.8" data-path="./">
            
                <a href="./">
            
                    
                    Simplificando Kubernetes día 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="../day-9/">
            
                <a href="../day-9/">
            
                    
                    Simplificando Kubernetes día 9
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.10" data-path="../day-10/">
            
                <a href="../day-10/">
            
                    
                    Simplificando Kubernetes día 10
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.11" data-path="../day-11/">
            
                <a href="../day-11/">
            
                    
                    Simplificando Kubernetes día 11
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.12" data-path="../day-12/">
            
                <a href="../day-12/">
            
                    
                    Simplificando Kubernetes día 12
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.13" data-path="../day-13/">
            
                <a href="../day-13/">
            
                    
                    Simplificando Kubernetes día 13
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.14" data-path="../day-14/">
            
                <a href="../day-14/">
            
                    
                    Simplificando Kubernetes día 14
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.15" data-path="../day-15/">
            
                <a href="../day-15/">
            
                    
                    Simplificando Kubernetes día 15
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Contribuir</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../CONTRIBUTING.html">
            
                <a href="../CONTRIBUTING.html">
            
                    
                    Cómo ayudar
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Publicado con HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Simplificando Kubernetes día 8</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="simplificando-kubernetes">Simplificando Kubernetes</h1>
<h2 id="día-8">Día 8</h2>
<p> </p>
<h3 id="contenido-del-día-8">Contenido del Día 8</h3>
<ul>
<li><a href="#simplificando-kubernetes">Simplificando Kubernetes</a><ul>
<li><a href="#día-8">Día 8</a><ul>
<li><a href="#contenido-del-día-8">Contenido del Día 8</a></li>
<li><a href="#qué-veremos-hoy">¿Qué veremos hoy?</a><ul>
<li><a href="#qué-son-los-secrets">¿Qué son los Secrets?</a><ul>
<li><a href="#cómo-funcionan-los-secrets">¿Cómo funcionan los Secrets?</a></li>
<li><a href="#tipos-de-secrets">Tipos de Secrets</a></li>
<li><a href="#antes-de-crear-un-secret-el-base64">Antes de crear un Secret, el Base64</a></li>
<li><a href="#creando-nuestro-primer-secret">Creando nuestro primer Secret</a></li>
<li><a href="#usando-nuestro-primer-secret">Usando nuestro primer Secret</a></li>
<li><a href="#creando-un-secreto-para-almacenar-credenciales-de-docker">Creando un Secreto para almacenar credenciales de Docker</a></li>
<li><a href="#creando-un-secret-tls">Creando un Secret TLS</a></li>
</ul>
</li>
<li><a href="#configmaps">ConfigMaps</a></li>
<li><a href="#operador-de-secretos-externos">Operador de Secretos Externos</a><ul>
<li><a href="#el-rol-destacado-del-eso">El Rol Destacado del ESO</a></li>
<li><a href="#conceptos-clave-del-operador-de-secretos-externos">Conceptos Clave del Operador de Secretos Externos</a></li>
<li><a href="#secretstore">SecretStore</a></li>
<li><a href="#externalsecret">ExternalSecret</a></li>
<li><a href="#clustersecretstore">ClusterSecretStore</a></li>
<li><a href="#control-de-acceso-y-seguridad">Control de Acceso y Seguridad</a></li>
</ul>
</li>
<li><a href="#configurando-el-external-secrets-operator">Configurando el External Secrets Operator</a><ul>
<li><a href="#qué-es-vault">¿Qué es Vault?</a></li>
<li><a href="#por-qué-usar-vault">¿Por Qué Usar Vault?</a></li>
<li><a href="#comandos-básicos-de-vault">Comandos Básicos de Vault</a></li>
<li><a href="#el-vault-en-el-contexto-de-kubernetes">El Vault en el Contexto de Kubernetes</a></li>
<li><a href="#instalación-y-configuración-de-vault-en-kubernetes">Instalación y Configuración de Vault en Kubernetes</a></li>
<li><a href="#requisitos-previos">Requisitos Previos</a></li>
<li><a href="#instalando-y-configurando-vault-con-helm">Instalando y Configurando Vault con Helm</a></li>
<li><a href="#agregar-el-repositorio-del-operador-de-secretos-externos-a-helm">Agregar el Repositorio del Operador de Secretos Externos a Helm</a></li>
<li><a href="#instalando-el-operador-de-secretos-externos">Instalando el Operador de Secretos Externos</a></li>
<li><a href="#verificación-de-la-instalación-de-eso">Verificación de la Instalación de ESO</a></li>
<li><a href="#creación-de-un-secreto-en-kubernetes">Creación de un Secreto en Kubernetes</a></li>
<li><a href="#configuración-del-clustersecretstore">Configuración del ClusterSecretStore</a></li>
<li><a href="#creación-de-un-externalsecret">Creación de un ExternalSecret</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#final-del-día-8">Final del Día 8</a></li>
</ul>
</li>
</ul>
<p> </p>
<h3 id="¿qué-veremos-hoy">¿Qué veremos hoy?</h3>
<p>Hoy es el día de hablar sobre dos cosas muy importantes en el mundo de Kubernetes, hoy vamos a hablar sobre <code>Secrets</code> y <code>ConfigMaps</code>.</p>
<p>Sí, estas dos piezas fundamentales te permitirán ejecutar tu aplicación en Kubernetes de la mejor manera posible, ya que son responsables de almacenar información sensible de tu aplicación, como contraseñas, tokens, claves de acceso, configuraciones, etc.</p>
<p>Después de hoy, comprenderás cómo funciona el almacenamiento de información sensible en Kubernetes y cómo puedes hacer que tu aplicación consuma esta información de la mejor manera posible.</p>
<p>¡Vamos allá!</p>
<p> </p>
<h4 id="¿qué-son-los-secrets">¿Qué son los Secrets?</h4>
<p>Los Secrets proporcionan una forma segura y flexible de gestionar información sensible, como contraseñas, tokens OAuth, claves SSH y otros datos que no deseas exponer en las configuraciones de tus aplicaciones.</p>
<p>Un Secret es un objeto que contiene un pequeño volumen de información sensible, como una contraseña, un token o una clave. Esta información puede ser consumida por Pods o utilizada por el sistema para realizar acciones en nombre de un Pod.</p>
<p> </p>
<h5 id="¿cómo-funcionan-los-secrets">¿Cómo funcionan los Secrets?</h5>
<p>Los Secrets se almacenan en <code>Etcd</code>, el almacén de datos distribuido de Kubernetes. Por defecto, se almacenan sin cifrar, aunque Etcd admite cifrado para proteger los datos almacenados en él. Además, el acceso a los Secrets está restringido a través del Control de Acceso Basado en Roles (<code>RBAC</code>), lo que permite controlar qué usuarios y Pods pueden acceder a qué Secrets.</p>
<p>Los Secrets pueden montarse en Pods como archivos en volúmenes o pueden utilizarse para completar variables de entorno para un contenedor dentro de un Pod. Cuando se actualiza un Secret, Kubernetes no actualiza automáticamente los volúmenes montados ni las variables de entorno que se refieren a él.</p>
<p> </p>
<h5 id="tipos-de-secrets">Tipos de Secrets</h5>
<p>Existen varios tipos de Secrets que puedes utilizar, dependiendo de tus necesidades específicas. A continuación, se muestran algunos de los tipos más comunes de Secrets:</p>
<ul>
<li><p><strong>Opaque Secrets</strong> - son los Secrets más simples y comunes. Almacenan datos arbitrarios, como claves de API, contraseñas y tokens. Los <code>Opaque Secrets</code> se codifican en base64 cuando se almacenan en Kubernetes, pero no se cifran. Pueden utilizarse para almacenar datos confidenciales, pero no son lo suficientemente seguros para almacenar información altamente sensible, como contraseñas de bases de datos.</p>
</li>
<li><p><strong>kubernetes.io/service-account-token</strong> - se utilizan para almacenar tokens de acceso a cuentas de servicio. Estos tokens se utilizan para autenticar <code>Pods</code> con la API de Kubernetes. Se montan automáticamente en <code>Pods</code> que utilizan cuentas de servicio.</p>
</li>
<li><p><strong>kubernetes.io/dockercfg</strong> y <strong>kubernetes.io/dockerconfigjson</strong> - se utilizan para almacenar credenciales de registro de Docker. Se utilizan para autenticar <code>Pods</code> con un registro de Docker. Se montan en <code>Pods</code> que utilizan imágenes de contenedor privadas.</p>
</li>
<li><p><strong>kubernetes.io/tls</strong>, <strong>kubernetes.io/ssh-auth</strong> y <strong>kubernetes.io/basic-auth</strong> - se utilizan para almacenar certificados TLS, claves SSH y credenciales de autenticación básica, respectivamente. Se utilizan para autenticar <code>Pods</code> con otros servicios.</p>
</li>
<li><p><strong>bootstrap.kubernetes.io/token</strong> - se utilizan para almacenar tokens de inicio de clúster. Se utilizan para autenticar nodos con el plano de control de Kubernetes.</p>
</li>
</ul>
<p>Hay algunos tipos más de Secrets, pero estos son los más comunes. Puedes encontrar una lista completa de tipos de Secrets en la documentación de Kubernetes.</p>
<p>Cada tipo de Secret tiene un formato diferente. Por ejemplo, los <code>Opaque Secrets</code> se almacenan como un mapa de strings, mientras que los <code>Secrets TLS</code> se almacenan como un mapa de strings con claves adicionales para almacenar certificados y claves, por lo que es importante saber qué tipo de Secret estás utilizando para almacenar los datos correctamente.</p>
<h5 id="antes-de-crear-un-secret-el-base64">Antes de crear un Secret, el Base64</h5>
<p>Antes de empezar a crear nuestros Secrets, necesitamos entender qué es <code>Base64</code>, ya que es un tema que a menudo genera muchas preguntas y que siempre está presente cuando hablamos de Secrets.</p>
<p>Primero, ¿es Base64 cifrado? No, Base64 no es cifrado, es un esquema de codificación binaria para texto que tiene como objetivo garantizar que los datos binarios puedan ser enviados por canales diseñados para tratar solo con texto. Esta codificación ayuda a asegurar que los datos permanezcan intactos sin modificación durante el transporte.</p>
<p><code>Base64</code> se utiliza comúnmente en varias aplicaciones, incluido el correo electrónico a través de MIME, el almacenamiento de contraseñas complejas y mucho más.</p>
<p>La codificación <code>Base64</code> convierte los datos binarios en una cadena de texto ASCII. Esta cadena contiene solo caracteres que se consideran seguros para su uso en URL, lo que hace que la codificación Base64 sea útil para codificar datos que se envían a través de Internet.</p>
<p>Sin embargo, la codificación Base64 no es una forma de cifrado y no debe usarse como tal. En particular, no proporciona confidencialidad. Cualquier persona que tenga acceso a la cadena codificada puede decodificarla fácilmente y recuperar los datos originales. Es importante entender esto para no almacenar información sensible en un formato codificado en Base64, ya que no es seguro.</p>
<p>Ahora que ya sabes qué es <code>Base64</code>, veamos cómo podemos codificar y decodificar una cadena utilizando <code>Base64</code>.</p>
<p>Para codificar una cadena en <code>Base64</code>, puedes usar el comando <code>base64</code> en Linux. Por ejemplo, para codificar la cadena <code>giropops</code> en <code>Base64</code>, puedes ejecutar el siguiente comando:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&apos;giropops&apos;</span> | base64
</code></pre>
<p>El comando anterior devolverá la cadena <code>Z2lyb3BvcHM=</code>.</p>
<p>Para decodificar una cadena en Base64, puedes usar el comando <code>base64</code> nuevamente, pero esta vez con la opción <code>-d</code>. Por ejemplo, para decodificar la cadena <code>Z2lyb3BvcHM=</code> en Base64, puedes ejecutar el siguiente comando:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&apos;Z2lyb3BvcHM=&apos;</span> | base64 -d
</code></pre>
<p>El comando anterior devolverá la cadena <code>giropops</code>, ¡tan simple como volar!</p>
<p>Estoy utilizando el parámetro <code>-n</code> en el comando <code>echo</code> para que no agregue una nueva línea al final de la cadena, ya que esto podría causar problemas al codificar y decodificar la cadena.</p>
<p>Ahora que ya estás listo para crear tus Secrets, ¡es hora de empezar a jugar!</p>
<h5 id="creando-nuestro-primer-secret">Creando nuestro primer Secret</h5>
<p>Ahora que ya sabes qué son los Secrets, que el <code>Base64</code> no es encriptación y cómo codificar y decodificar una cadena usando <code>Base64</code>, vamos a crear nuestro primer Secret.</p>
<p>Primero, crearemos un Secret del tipo <code>Opaque</code>. Este es el tipo de Secret más común y se usa para almacenar información arbitraria.</p>
<p>Para crear un Secret del tipo <code>Opaque</code>, necesitas crear un archivo YAML que defina el Secret. Por ejemplo, puedes crear un archivo llamado <code>giropops-secret.yaml</code> con el siguiente contenido:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">giropops-secret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>
<span class="hljs-attr">data:</span> <span class="hljs-comment"># Inicio de los datos</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">SmVmZXJzb25fbGluZG8=</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">Z2lyb3BvcHM=</span>
</code></pre>
<p> </p>
<p>El archivo anterior define un Secret llamado <code>giropops-secret</code> con dos campos de datos llamados <code>username</code> y <code>password</code>. El campo <code>password</code> contiene la cadena <code>giropops</code> codificada en <code>Base64</code>. Mi pregunta es: ¿cuál es el valor del campo <code>username</code>?</p>
<p>Si lo descubres, te reto a que hagas un tweet o una publicación en otra red social con el valor del campo <code>username</code> y las etiquetas #desafioDay8 y #DescomplicandoKubernetes. Si lo haces, te daré un premio, pero no te diré cuál es, ¡es un secreto! :D</p>
<p>Otra información importante que proporcionamos para este Secret fue su tipo, que es <code>Opaque</code>. Puedes ver que el tipo de Secret se define en el campo <code>type</code> del archivo YAML.</p>
<p>Ahora que has creado el archivo YAML, puedes crear el Secret usando el comando <code>kubectl create</code> o <code>kubectl apply</code>. Por ejemplo, para crear el Secret usando el comando <code>kubectl create</code>, ejecuta el siguiente comando:</p>
<pre><code class="lang-bash">kubectl create -f giropops-secret.yaml

secret/giropops-secret created
</code></pre>
<p> </p>
<p>¡Listo, nuestro primer Secret ha sido creado! Ahora puedes ver el Secret usando el comando <code>kubectl get</code>:</p>
<pre><code class="lang-bash">kubectl get secret giropops-secret

NAME              TYPE     DATA   AGE
giropops-secret   Opaque   2      10s
</code></pre>
<p> </p>
<p>La salida muestra el nombre del Secret, su tipo, la cantidad de datos que almacena y cuánto tiempo ha pasado desde su creación.</p>
<p>Si deseas ver los datos almacenados en el Secret, puedes usar el comando <code>kubectl get</code> con la opción <code>-o yaml</code>:</p>
<pre><code class="lang-bash">kubectl get secret giropops-secret -o yaml

apiVersion: v1
data:
  password: Z2lyb3BvcHM=
  username: SmVmZXJzb25fbGluZG8=
kind: Secret
metadata:
  creationTimestamp: <span class="hljs-string">&quot;2023-05-21T10:38:39Z&quot;</span>
  name: giropops-secret
  namespace: default
  resourceVersion: <span class="hljs-string">&quot;466&quot;</span>
  uid: ac816e95-8896-4ad4-9e64-4ee8258a8cda
<span class="hljs-built_in">type</span>: Opaque
</code></pre>
<p> </p>
<p>¡Así de simple! Una vez más, los datos almacenados en el Secret no están encriptados y cualquier persona con acceso al Secret puede decodificarlos fácilmente, por lo que es fundamental controlar el acceso a los Secrets y no almacenar información sensible en ellos.</p>
<p>También puedes ver los detalles del Secret usando el comando <code>kubectl describe</code>:</p>
<pre><code class="lang-bash">kubectl describe secret giropops-secret

Name:         giropops-secret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
password:  8 bytes
username:  15 bytes
</code></pre>
<p> </p>
<p>La salida del comando <code>kubectl describe</code> es similar al contenido del archivo YAML que creaste para definir el Secret, pero con información adicional, como el namespace del Secret, las etiquetas y las anotaciones, que también puedes definir en el archivo YAML.</p>
<p>Si deseas crear este mismo Secret utilizando el comando <code>kubectl create secret</code>, puedes ejecutar el siguiente comando:</p>
<pre><code class="lang-bash">kubectl create secret generic giropops-secret --from-literal=username=&lt;SECRETO&gt; --from-literal=password=giropops
</code></pre>
<p> </p>
<p>Fácil, aquí estamos utilizando el parámetro <code>--from-literal</code> para definir los datos del Secret. Otras opciones son <code>--from-file</code> y <code>--from-env-file</code>, que puedes utilizar para definir los datos del Secret a partir de un archivo o variables de entorno.</p>
<p>Si comparas las cadenas de los campos <code>username</code> y <code>password</code> del Secret creado utilizando el comando <code>kubectl create secret</code> con las cadenas de los campos <code>username</code> y <code>password</code> del Secret creado utilizando el archivo YAML, notarás que son idénticas. Esto se debe porque el comando <code>kubectl create secret</code> automáticamente codifica los datos en Base64.</p>
<p> </p>
<h5 id="usando-nuestro-primer-secret">Usando nuestro primer Secret</h5>
<p>Ahora que ya hemos creado nuestro primer Secret, es hora de aprender cómo usarlo en un Pod.</p>
<p>En este primer ejemplo, solo mostraré cómo usar el Secret en un Pod, pero aún sin ninguna &quot;función&quot; especial, solo para demostrar cómo usar el Secret.</p>
<p>Para utilizar el Secret en un Pod, debes definir el campo <code>spec.containers[].env[].valueFrom.secretKeyRef</code> en el archivo YAML del Pod. Estoy presentando este campo en este formato para que puedas empezar a familiarizarte con él, ya que lo utilizarás bastante para buscar información más específica en la línea de comandos, por ejemplo, usando el comando <code>kubectl get</code>.</p>
<p>Volviendo al tema principal, necesitamos crear nuestro Pod, ¡así que vamos allá! Crea un archivo llamado <code>giropops-pod.yaml</code> con el siguiente contenido:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">giropops-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">giropops-container</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">env:</span> <span class="hljs-comment"># Inicio de la definición de las variables de entorno</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">USERNAME</span> <span class="hljs-comment"># Nombre de la variable de entorno que se utilizará en el Pod</span>
      <span class="hljs-attr">valueFrom:</span> <span class="hljs-comment"># Inicio de la definición de dónde se buscará el valor de la variable de entorno</span>
        <span class="hljs-attr">secretKeyRef:</span> <span class="hljs-comment"># Inicio de la definición de que el valor de la variable de entorno se buscará en un Secreto, a través de una clave</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">giropops-secret</span> <span class="hljs-comment"># Nombre del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">username</span> <span class="hljs-comment"># Nombre de la clave del campo del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PASSWORD</span> <span class="hljs-comment"># Nombre de la variable de entorno que se utilizará en el Pod</span>
      <span class="hljs-attr">valueFrom:</span> <span class="hljs-comment"># Inicio de la definición de dónde se buscará el valor de la variable de entorno</span>
        <span class="hljs-attr">secretKeyRef:</span> <span class="hljs-comment"># Inicio de la definición de que el valor de la variable de entorno se buscará en un Secreto, a través de una clave</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">giropops-secret</span> <span class="hljs-comment"># Nombre del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">password</span> <span class="hljs-comment"># Nombre de la clave del campo del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod</span>
</code></pre>
<p> </p>
<p>He añadido comentarios en las líneas que son nuevas para ti, para que puedas entender lo que hace cada línea.</p>
<p>Pero ahora proporcionaré una explicación más detallada sobre el campo <code>spec.containers[].env[].valueFrom.secretKeyRef</code>:</p>
<ul>
<li><p><code>spec.containers[].env[].valueFrom.secretKeyRef.name</code>: el nombre del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod.</p>
</li>
<li><p><code>spec.containers[].env[].valueFrom.secretKeyRef.key</code>: la clave del campo del Secreto que contiene el valor de la variable de entorno que se utilizará en el Pod.</p>
</li>
</ul>
<p>Con esto, tendremos un Pod que tendrá un contenedor llamado <code>giropops-container</code> con dos variables de entorno, <code>USERNAME</code> y <code>PASSWORD</code>, que tendrán los valores definidos en el Secret <code>giropops-secret</code>.</p>
<p>Ahora crearemos el Pod utilizando el comando <code>kubectl apply</code>:</p>
<pre><code class="lang-bash">Copy code
kubectl apply -f giropops-pod.yaml

pod/giropops-pod created
</code></pre>
<p> </p>
<p>Ahora vamos a verificar si el Pod ha sido creado y si los Secrets han sido inyectados en el Pod:</p>
<pre><code class="lang-bash">kubectl get pods

NAME           READY   STATUS    RESTARTS   AGE
giropops-pod   1/1     Running   0          2m
</code></pre>
<p> </p>
<p>Para verificar si los Secrets han sido inyectados en el Pod, puedes utilizar el comando <code>kubectl exec</code> para ejecutar el comando <code>env</code> dentro del contenedor del Pod:</p>
<pre><code class="lang-bash">kubectl <span class="hljs-built_in">exec</span> giropops-pod -- env

PATH=/usr/<span class="hljs-built_in">local</span>/sbin:/usr/<span class="hljs-built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=giropops-pod
NGINX_VERSION=1.23.4
NJS_VERSION=0.7.11
PKG_RELEASE=1~bullseye
PASSWORD=giropops
USERNAME=CENSURADO
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
HOME=/root
</code></pre>
<p> </p>
<p>Mira allí nuestros Secretos como variables de entorno dentro del contenedor del Pod.</p>
<p>¡Listo! ¡Tarea ejecutada con éxito! \o/</p>
<p>Ahora creo que podemos avanzar hacia los próximos tipos de Secrets.</p>
<p> </p>
<h5 id="creando-un-secreto-para-almacenar-credenciales-de-docker">Creando un Secreto para almacenar credenciales de Docker</h5>
<p>Docker Hub es un servicio de registro de imágenes Docker que te permite almacenar y compartir imágenes Docker de forma pública o privada. En 2022, Docker Hub comenzó a limitar la cantidad de descargas de imágenes Docker públicas a 100 descargas cada 6 horas para usuarios no autenticados, y para usuarios autenticados, el límite es de 200 descargas cada 6 horas.</p>
<p>Pero el punto aquí es que puedes usar Docker Hub para almacenar imágenes Docker de forma privada, y para hacerlo necesitas una cuenta en Docker Hub. Para acceder a tu cuenta en Docker Hub, necesitas un nombre de usuario y una contraseña. ¿Entiendes hacia dónde voy? :D</p>
<p>Para que Kubernetes pueda acceder a Docker Hub, necesitas crear un Secreto que almacene el nombre de usuario y la contraseña de tu cuenta en Docker Hub, y luego debes configurar Kubernetes para que utilice este Secreto.</p>
<p>Cuando ejecutas <code>docker login</code> y la autenticación se realiza con éxito, Docker crea un archivo llamado <code>config.json</code> en el directorio <code>~/.docker/</code> de tu usuario. Este archivo contiene el nombre de usuario y la contraseña de tu cuenta en Docker Hub, y es este archivo el que debes utilizar para crear tu Secreto.</p>
<p>El primer paso es tomar el contenido de tu archivo <code>config.json</code> y codificarlo en base64, para lo cual puedes usar el comando <code>base64</code>:</p>
<pre><code class="lang-bash">base64 ~/.docker/config.json

QXF1aSB0ZW0gcXVlIGVzdGFyIG8gY29udGXDumRvIGRvIHNldSBjb25maWcuanNvbiwgY29pc2EgbGluZGEgZG8gSmVmaW0=
</code></pre>
<p> </p>
<p>¡Entonces, adelante! Crea un archivo llamado <code>dockerhub-secret.yaml</code> con el siguiente contenido:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-hub-secret</span> <span class="hljs-comment"># nombre del Secret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/dockerconfigjson</span> <span class="hljs-comment"># tipo de Secret, en este caso, es un Secret que almacena credenciales de Docker</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-string">.dockerconfigjson:</span> <span class="hljs-string">|</span>  <span class="hljs-comment"># reemplace este valor con el contenido de su archivo config.json codificado en base64</span>
    <span class="hljs-string">QXF1aSB0ZW0gcXVlIGVzdGFyIG8gY29udGXDumRvIGRvIHNldSBjb25maWcuanNvbiwgY29pc2EgbGluZGEgZG8gSmVmaW0=</span>
</code></pre>
<p> </p>
<p>Lo que tenemos de nuevo aquí es en el campo <code>type</code>, que define el tipo del Secret, y en este caso es un Secret que almacena credenciales de Docker. Y en el campo data, tenemos el campo <code>dockerconfigjson</code>, que es el nombre del campo del Secret que almacena el contenido del archivo <code>config.json</code> codificado en <code>base64</code>.</p>
<p>Ahora crearemos el Secret utilizando el comando <code>kubectl apply</code>:</p>
<pre><code class="lang-bash">kubectl apply -f dockerhub-secret.yaml

secret/docker-hub-secret created
</code></pre>
<p> </p>
<p>Para listar el Secret que acabamos de crear, puedes utilizar el comando <code>kubectl get</code>:</p>
<pre><code class="lang-bash">kubectl get secrets

NAME                TYPE                             DATA   AGE
docker-hub-secret   kubernetes.io/dockerconfigjson   1      1s
</code></pre>
<p> </p>
<p>Secret creada, ¡ahora ya podemos probar el acceso al Docker Hub!</p>
<p>Ahora Kubernetes ya tiene acceso al Docker Hub, y puedes usar Kubernetes para hacer pull de imágenes Docker privadas del Docker Hub.</p>
<p>Una cosa importante, siempre que necesites crear un Pod que requiera utilizar una imagen Docker privada del Docker Hub, necesitas configurar el Pod para usar el Secret que almacena las credenciales del Docker Hub, y para eso necesitas usar el campo <code>spec.imagePullSecrets</code> en el archivo YAML del Pod.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mi-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mi-container</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">mi-imagen-privada</span>
  <span class="hljs-attr">imagePullSecrets:</span> <span class="hljs-comment"># campo que define el Secret que almacena las credenciales del Docker Hub</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-hub-secret</span> <span class="hljs-comment"># nombre del Secret</span>
</code></pre>
<p> </p>
<p>Observa la utilización del campo <code>spec.imagePullSecrets</code> en el archivo YAML del Pod, y el campo <code>name</code> que define el nombre del Secret que almacena las credenciales del Docker Hub. Esto es todo lo que necesitas hacer para que Kubernetes pueda acceder al Docker Hub.</p>
<p> </p>
<h5 id="creando-un-secret-tls">Creando un Secret TLS</h5>
<p>El Secret <code>kubernetes.io/tls</code> se utiliza para almacenar certificados TLS y claves privadas. Se utilizan para proporcionar seguridad en la comunicación entre servicios en Kubernetes. Por ejemplo, puedes utilizar un Secreto TLS para configurar HTTPS en tu servicio web.</p>
<p>Para crear un Secreto TLS, necesitas tener un certificado TLS y una clave privada, y debes codificar el certificado y la clave privada en base64 antes de crear el Secreto.</p>
<p>Crearemos un Secreto TLS para nuestro servicio web, pero primero debes tener un certificado TLS y una clave privada.</p>
<p>Para crear un certificado TLS y una clave privada, puedes utilizar el comando <code>openssl</code>:</p>
<pre><code class="lang-bash">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout clave-privada.key -out certificado.crt
</code></pre>
<p> </p>
<p>En el comando anterior, estamos creando un certificado TLS y una clave privada, y el certificado y la clave privada se almacenarán en los archivos <code>certificado.crt</code> y <code>clave-privada.key</code>, respectivamente. Puedes sustituir los nombres de los archivos por cualquier nombre que quieras.
Estamos usando el comando <code>openssl</code> para crear un certificado TLS auto-firmado, y para ello necesitas responder algunas preguntas, como el país, estado, ciudad, etc. Puedes responder cualquier cosa, no hay problema. Este certificado TLS auto-firmado es solo para fines de prueba, y no debe ser utilizado en producción. Estamos pasando el parámetro <code>-nodes</code> para que la clave privada no sea cifrada con una contraseña, y el parámetro <code>-days</code> para definir la validez del certificado TLS, que en este caso es de 365 días. El parámetro <code>-newkey</code> se utiliza para definir el algoritmo de cifrado de la clave privada, que en este caso es <code>rsa:2048</code>, un algoritmo de cifrado asimétrico que utiliza claves de 2048 bits.</p>
<p>No quiero entrar en detalles sobre lo que es un certificado TLS y una clave privada, pero, básicamente, un certificado TLS (Transport Layer Security) se utiliza para autenticar y establecer una conexión segura entre dos partes, como un cliente y un servidor. Contiene información sobre la entidad a la que se emitió y la entidad que lo emitió, así como la clave pública de la entidad a la que se emitió.</p>
<p>La clave privada, por otro lado, se utiliza para descifrar la información que fue cifrada con la clave pública. Debe mantenerse en secreto y nunca compartida, ya que cualquier persona con acceso a la clave privada puede descifrar la comunicación segura. Juntos, el certificado TLS y la clave privada forman un par de claves que permite la autenticación y la comunicación segura entre las partes.</p>
<p>¿Entendido? Espero que sí, porque no voy a entrar en más detalles sobre eso. hahaha</p>
<p>Ahora volvamos al foco en la creación del Secret TLS.</p>
<p>Con el certificado TLS y la clave privada creados, vamos a crear nuestro Secret, solo para cambiar un poco, vamos a crear el Secret usando el comando <code>kubectl apply</code>:</p>
<pre><code class="lang-bash">kubectl create secret tls mi-servicio-web-tls-secret --cert=certificado.crt --key=clave-privada.key

secret/mi-servicio-web-tls-secret created
</code></pre>
<p> </p>
<p>Vamos a comprobar si el Secret ha sido creado:</p>
<pre><code class="lang-bash">kubectl get secrets
NAME                         TYPE                             DATA   AGE
mi-servicio-web-tls-secret   kubernetes.io/tls                2      4s
</code></pre>
<p> </p>
<p>Sí, el Secret está ahí y es del tipo <code>kubernetes.io/tls</code>.</p>
<p>Si deseas ver el contenido del Secret, puedes utilizar el comando <code>kubectl get secret</code> con el parámetro <code>-o yaml</code>:</p>
<pre><code class="lang-bash">kubectl get secret mi-servicio-web-tls-secret -o yaml
</code></pre>
<p> </p>
<p>Ahora puedes utilizar este Secret para ejecutar Nginx con HTTPS, y para ello necesitas utilizar el campo <code>spec.tls</code> en el archivo YAML del Pod:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config-volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/nginx.conf</span>
          <span class="hljs-attr">subPath:</span> <span class="hljs-string">nginx.conf</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-tls</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/tls</span>
    <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config-volume</span>
      <span class="hljs-attr">configMap:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-tls</span>
      <span class="hljs-attr">secret:</span>
        <span class="hljs-attr">secretName:</span> <span class="hljs-string">mi-servicio-web-tls-secret</span>
        <span class="hljs-attr">items:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">certificado.crt</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">certificado.crt</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">clave-privada.key</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">clave-privada.key</span>
</code></pre>
<p> </p>
<p>Aquí tenemos mucha información nueva, así que vamos por partes.</p>
<p>Lo primero de lo que debemos hablar es sobre <code>spec.containers</code>, en particular sobre los volúmenes, que es el campo <code>spec.containers.volumeMounts</code>.</p>
<p>El campo <code>spec.containers.volumeMounts</code> se utiliza para montar un volumen en un directorio dentro del contenedor. En nuestro caso, estamos montando dos volúmenes, uno para el archivo de configuración de Nginx y otro para el certificado TLS y la clave privada.</p>
<p>Utilizamos el campo <code>spec.volumes</code> para definir los volúmenes que se utilizarán en el Pod, y estamos definiendo dos volúmenes, <code>nginx-config-volume</code> y <code>nginx-tls</code>.</p>
<p>El volumen <code>nginx-config-volume</code> es un volumen de tipo <code>configMap</code> y se utiliza para montar el archivo de configuración de Nginx, que está almacenado en el ConfigMap <code>nginx-config</code>. El próximo tema trata sobre ConfigMaps, así que no te preocupes por eso por ahora.</p>
<p>El volumen <code>nginx-tls</code> es un volumen de tipo <code>secret</code> y se utiliza para montar el Secret <code>mi-servicio-web-tls-secret</code>, que contiene el certificado TLS y la clave privada que se utilizarán para configurar HTTPS en Nginx.</p>
<p>Y como estamos configurando un Nginx para utilizar nuestro Secret, debemos indicar dónde queremos que se monten los archivos del Secret. Para ello, utilizamos el campo <code>spec.containers.volumeMounts.path</code> para especificar el directorio en el que queremos que se monten los archivos del Secret, en este caso, el directorio <code>/etc/nginx/tls</code>.</p>
<p>Mencioné que el volumen <code>nginx-config-volume</code> es un volumen de tipo <code>configMap</code>, lo que es una excelente introducción para el próximo tema, que trata sobre ConfigMaps. :D</p>
<p>Por lo tanto, continuaremos con nuestro ejemplo de cómo utilizar Nginx con HTTPS en el próximo tema sobre ConfigMaps. ¡Vamos allá! \o/</p>
<h4 id="configmaps">ConfigMaps</h4>
<p>Los ConfigMaps se utilizan para almacenar datos de configuración, como variables de entorno, archivos de configuración, etc. Son muy útiles para almacenar datos de configuración que pueden ser utilizados por varios Pods.</p>
<p>Los ConfigMaps son una forma eficiente de desacoplar los parámetros de configuración de las imágenes de contenedores. Esto permite que tengas la misma imagen de contenedor en diferentes entornos, como desarrollo, prueba y producción, con diferentes configuraciones.</p>
<p>Aquí hay algunos puntos importantes sobre el uso de ConfigMaps en Kubernetes:</p>
<ul>
<li><p>Actualizaciones: Los ConfigMaps no se actualizan automáticamente en los pods que los utilizan. Si actualizas un ConfigMap, los pods existentes no recibirán la nueva configuración. Para que un pod reciba la nueva configuración, necesitas recrear el pod.</p>
</li>
<li><p>Múltiples ConfigMaps: Es posible usar múltiples ConfigMaps para un único pod. Esto es útil cuando tienes diferentes aspectos de la configuración que quieres mantener separados.</p>
</li>
<li><p>Variables de entorno: Además de montar el ConfigMap en un volumen, también es posible usar el ConfigMap para definir variables de entorno para los contenedores en el pod.</p>
</li>
<li><p>Inmutabilidad: A partir de la versión 1.19 de Kubernetes, es posible hacer ConfigMaps (y Secrets) inmutables, lo que puede mejorar el rendimiento de tu clúster si tienes muchos ConfigMaps o Secrets.</p>
</li>
</ul>
<p>Como en el ejemplo del capítulo anterior, donde creamos un Pod con Nginx y usamos un ConfigMap para almacenar el archivo de configuración de Nginx, el <code>ConfigMap</code> se utiliza para almacenar el archivo de configuración de Nginx, en lugar de almacenar el archivo de configuración dentro del Pod, teniendo así un Pod más limpio y más fácil de mantener. Y claro, siempre es bueno usar las cosas para lo que fueron hechas, y el ConfigMap fue hecho para almacenar datos de configuración.</p>
<p>Continuemos con nuestro ejemplo de cómo usar Nginx con HTTPS, pero ahora usando un ConfigMap para almacenar el archivo de configuración de Nginx.</p>
<p>Vamos a crear el archivo de configuración de Nginx llamado <code>nginx.conf</code>, que será utilizado por el ConfigMap:</p>
<pre><code class="lang-bash">events { } <span class="hljs-comment"># configuración de eventos</span>

http { <span class="hljs-comment"># configuración del protocolo HTTP, que es el protocolo que Nginx va a usar</span>
  server { <span class="hljs-comment"># configuración del servidor</span>
    listen 80; <span class="hljs-comment"># puerto que Nginx va a escuchar</span>
    listen 443 ssl; <span class="hljs-comment"># puerto que Nginx va a escuchar para HTTPS y pasando el parámetro ssl para habilitar HTTPS</span>

    ssl_certificate /etc/nginx/tls/certificado.crt; <span class="hljs-comment"># ruta del certificado TLS</span>
    ssl_certificate_key /etc/nginx/tls/clave-privada.key; <span class="hljs-comment"># ruta de la clave privada</span>

    location / { <span class="hljs-comment"># configuración de la ruta /</span>
      <span class="hljs-built_in">return</span> 200 <span class="hljs-string">&apos;¡Bienvenido a Nginx!\n&apos;</span>; <span class="hljs-comment"># devuelve el código 200 y el mensaje ¡Bienvenido a Nginx!</span>
      add_header Content-Type text/plain; <span class="hljs-comment"># añade el header Content-Type con el valor text/plain</span>
    } 
  }
}
</code></pre>
<p> </p>
<p>He dejado el contenido del archivo anterior con comentarios para facilitar la comprensión.</p>
<p>Lo que el archivo anterior está haciendo es:</p>
<ul>
<li>Configurando Nginx para escuchar en los puertos 80 y 443, siendo el puerto 443 utilizado para HTTPS.</li>
<li>Configurando Nginx para usar el certificado TLS y la clave privada que se encuentran en el directorio <code>/etc/nginx/tls</code>.</li>
<li>Configurando la ruta <code>/</code> para devolver el código 200 y el mensaje <code>¡Bienvenido a Nginx!</code> con el header <code>Content-Type</code> con el valor <code>text/plain</code>.</li>
</ul>
<p>Ahora vamos a crear el ConfigMap <code>nginx-config</code> con el archivo de configuración de Nginx:</p>
<pre><code class="lang-bash">kubectl create configmap nginx-config --from-file=nginx.conf
</code></pre>
<p> </p>
<p>Muy sencillo, ¿verdad? :)</p>
<p>Lo que estamos haciendo es crear un ConfigMap llamado <code>nginx-config</code> con el contenido del archivo <code>nginx.conf</code>.
Podemos hacer lo mismo a través de un manifiesto, como en el ejemplo a continuación:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">nginx.conf:</span> <span class="hljs-string">|
    events { }
</span>
    <span class="hljs-string">http</span> {
      <span class="hljs-string">server</span> {
        <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span>
        <span class="hljs-string">listen</span> <span class="hljs-number">443</span> <span class="hljs-string">ssl;</span>

        <span class="hljs-string">ssl_certificate</span> <span class="hljs-string">/etc/nginx/tls/certificado.crt;</span>
        <span class="hljs-string">ssl_certificate_key</span> <span class="hljs-string">/etc/nginx/tls/clave-privada.key;</span>

        <span class="hljs-string">location</span> <span class="hljs-string">/</span> {
          <span class="hljs-string">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&apos;¡Bienvenido a Nginx!\n&apos;</span><span class="hljs-string">;</span>
          <span class="hljs-string">add_header</span> <span class="hljs-string">Content-Type</span> <span class="hljs-string">text/plain;</span>
        }
      }
    }
</code></pre>
<p> </p>
<p>El archivo es muy similar a los manifiestos de <code>Secret</code>, pero con algunas diferencias:</p>
<ul>
<li>El campo <code>kind</code> es <code>ConfigMap</code> en lugar de <code>Secret</code>.</li>
<li>El campo <code>data</code> se utiliza para definir el contenido del ConfigMap, y el campo <code>data</code> es un mapa de clave-valor, donde la clave es el nombre del archivo y el valor es el contenido del archivo. Usamos el carácter <code>|</code> para definir el valor del campo <code>data</code> como un bloque de texto, y así podemos definir el contenido del archivo <code>nginx.conf</code> sin la necesidad de usar el carácter <code>\n</code> para romper las líneas del archivo.</li>
</ul>
<p>Ahora solo queda aplicar el manifiesto anterior:</p>
<pre><code class="lang-bash">kubectl apply -f nginx-config.yaml
</code></pre>
<p> </p>
<p>Para ver el contenido del ConfigMap que creamos, basta con ejecutar el comando:</p>
<pre><code class="lang-bash">kubectl get configmap nginx-config -o yaml
</code></pre>
<p> </p>
<p>También puedes usar el comando <code>kubectl describe configmap nginx-config</code> para ver el contenido del ConfigMap, pero el comando <code>kubectl get configmap nginx-config -o yaml</code> es mucho más completo.</p>
<p>Ahora que ya tenemos nuestro <code>ConfigMap</code> creado, vamos a aplicar el manifiesto que creamos en el capítulo anterior. Lo copiaré aquí para facilitar:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config-volume</span> <span class="hljs-comment"># nombre del volumen que vamos a usar para montar el archivo de configuración de Nginx</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/nginx.conf</span> <span class="hljs-comment"># ruta donde se montará el archivo de configuración de Nginx</span>
      <span class="hljs-attr">subPath:</span> <span class="hljs-string">nginx.conf</span> <span class="hljs-comment"># nombre del archivo de configuración de Nginx</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-tls</span> <span class="hljs-comment"># nombre del volumen que vamos a usar para montar el certificado TLS y la clave privada</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/tls</span> <span class="hljs-comment"># ruta donde se montarán el certificado TLS y la clave privada</span>
  <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># lista de volúmenes que vamos a usar en el Pod</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config-volume</span> <span class="hljs-comment"># nombre del volumen que vamos a usar para montar el archivo de configuración de Nginx</span>
    <span class="hljs-attr">configMap:</span> <span class="hljs-comment"># tipo del volumen que vamos a usar</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config</span> <span class="hljs-comment"># nombre del ConfigMap que vamos a usar</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-tls</span> <span class="hljs-comment"># nombre del volumen que vamos a usar para montar el certificado TLS y la clave privada</span>
    <span class="hljs-attr">secret:</span> <span class="hljs-comment"># tipo del volumen que vamos a usar</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">mi-servicio-web-tls-secret</span> <span class="hljs-comment"># nombre del Secret que vamos a usar</span>
      <span class="hljs-attr">items:</span> <span class="hljs-comment"># lista de archivos que vamos a montar, ya que dentro del secret tenemos dos archivos, el certificado TLS y la clave privada</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">tls.crt</span> <span class="hljs-comment"># nombre del archivo que vamos a montar, nombre que está en el campo `data` del Secret</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">certificado.crt</span> <span class="hljs-comment"># nombre del archivo que se montará, nombre que se usará en el campo `ssl_certificate` del archivo de configuración de Nginx</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">tls.key</span> <span class="hljs-comment"># nombre del archivo que vamos a montar, nombre que está en el campo `data` del Secret</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">clave-privada.key</span> <span class="hljs-comment"># nombre del archivo que se montará, nombre que se usará en el campo `ssl_certificate_key` del archivo de configuración de Nginx</span>
</code></pre>
<p> </p>
<p>Ahora solo queda aplicar el manifiesto anterior:</p>
<pre><code class="lang-bash">kubectl apply -f nginx.yaml
</code></pre>
<p> </p>
<p>Listando los Pods:</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<p>Ahora necesitamos crear un Service para exponer el Pod que creamos:</p>
<pre><code class="lang-bash">kubectl expose pod nginx
</code></pre>
<p> </p>
<p>Listando los Services:</p>
<pre><code class="lang-bash">kubectl get services
</code></pre>
<p> </p>
<p>Vamos a hacer el <code>port-forward</code> para probar si nuestro Nginx está funcionando:</p>
<pre><code class="lang-bash">kubectl port-forward service/nginx 4443:443
</code></pre>
<p> </p>
<p>El comando anterior realizará el <code>port-forward</code> del puerto 443 del Service <code>nginx</code> al puerto 4443 de tu computadora, ¡el <code>port-forward</code> nos está salvando nuevamente! :)</p>
<p>Utilizaremos <code>curl</code> para comprobar si nuestro Nginx está funcionando:&quot;</p>
<pre><code class="lang-bash">curl -k https://localhost:4443

¡Bienvenido a Nginx!
</code></pre>
<p> </p>
<p>¡Funciona maravillosamente!
Recuerda que este es un ejemplo muy simple; el objetivo aquí es mostrar cómo usar ConfigMap y Secret para montar archivos dentro de un Pod. El certificado TLS y la clave privada que usamos aquí son auto-firmados y no se recomiendan para su uso en producción, ni son aceptados por los navegadores, pero son adecuados para pruebas.</p>
<p>Creo que ya has comprendido cómo funciona ConfigMap, y recuerda que puedes usar ConfigMap no solo para montar archivos, sino también para definir variables de entorno, lo cual es muy útil cuando necesitas pasar una configuración a un contenedor a través de una variable de entorno.</p>
<p>Si deseas hacer que un ConfigMap sea inmutable, puedes utilizar el campo <code>immutable</code> en el manifiesto del ConfigMap, como se muestra en el siguiente ejemplo:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config</span>
  <span class="hljs-attr">immutable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Convierte el ConfigMap en inmutable</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">nginx.conf:</span> <span class="hljs-string">|
    events { }
</span>
    <span class="hljs-string">http</span> {
      <span class="hljs-string">server</span> {
        <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span>
        <span class="hljs-string">listen</span> <span class="hljs-number">443</span> <span class="hljs-string">ssl;</span>

        <span class="hljs-string">ssl_certificate</span> <span class="hljs-string">/etc/nginx/tls/certificado.crt;</span>
        <span class="hljs-string">ssl_certificate_key</span> <span class="hljs-string">/etc/nginx/tls/clave-privada.key;</span>

        <span class="hljs-string">location</span> <span class="hljs-string">/</span> {
          <span class="hljs-string">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&apos;¡Bienvenido a Nginx!\n&apos;</span><span class="hljs-string">;</span>
          <span class="hljs-string">add_header</span> <span class="hljs-string">Content-Type</span> <span class="hljs-string">text/plain;</span>
        }
      }
    }
</code></pre>
<p> </p>
<p>Con esto, no será posible cambiar el ConfigMap, y si intentas modificarlo, Kubernetes devolverá un error.</p>
<p>Si deseas colocar el ConfigMap en un espacio de nombres específico, puedes utilizar el campo <code>namespace</code> en el manifiesto del ConfigMap, como se muestra en el siguiente ejemplo:&quot;</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-config</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mi-namespace</span> <span class="hljs-comment"># coloca el ConfigMap en el espacio de nombres mi-namespace</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">nginx.conf:</span> <span class="hljs-string">|
    events { }
</span>
    <span class="hljs-string">http</span> {
      <span class="hljs-string">server</span> {
        <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span>
        <span class="hljs-string">listen</span> <span class="hljs-number">443</span> <span class="hljs-string">ssl;</span>

        <span class="hljs-string">ssl_certificate</span> <span class="hljs-string">/etc/nginx/tls/certificado.crt;</span>
        <span class="hljs-string">ssl_certificate_key</span> <span class="hljs-string">/etc/nginx/tls/clave-privada.key;</span>

        <span class="hljs-string">location</span> <span class="hljs-string">/</span> {
          <span class="hljs-string">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&apos;¡Bienvenido a Nginx!\n&apos;</span><span class="hljs-string">;</span>
          <span class="hljs-string">add_header</span> <span class="hljs-string">Content-Type</span> <span class="hljs-string">text/plain;</span>
        }
      }
    }
</code></pre>
<p> </p>
<p>En resumen, creo que hemos cubierto bastante sobre ConfigMap. ¿Estás listo para pasar al próximo tema? ¡Vamos adelante! \o/</p>
<p> </p>
<h4 id="operador-de-secretos-externos">Operador de Secretos Externos</h4>
<p>El Operador de Secretos Externos (External Secrets Operator, ESO) es un maestro de los secretos en Kubernetes, capaz de trabajar en perfecta armonía con una amplia variedad de sistemas de gestión de secretos externos. Esto incluye, pero no se limita a, gigantes como AWS Secrets Manager, HashiCorp Vault, Google Secrets Manager, Azure Key Vault e IBM Cloud Secrets Manager.</p>
<p>El papel del ESO es buscar información en estas API externas y llevarla al entorno de Kubernetes, convirtiéndola en Secretos de Kubernetes listos para usar.</p>
<h5 id="el-rol-destacado-del-eso">El Rol Destacado del ESO</h5>
<p>La gran misión del ESO es sincronizar secretos desde las API externas al entorno de Kubernetes. Para lograrlo, utiliza tres recursos personalizados de la API: ExternalSecret, SecretStore y ClusterSecretStore. Estos recursos crean un puente entre Kubernetes y las API externas, permitiendo que los secretos se gestionen y utilicen de manera amigable y eficiente.</p>
<p>Para simplificar, nuestro ESO es el encargado de llevar los Secretos de Kubernetes a un nuevo nivel, permitiéndote utilizar herramientas especializadas en la gestión de secretos, como Hashicorp Vault, por ejemplo, que ya conoces.</p>
<h5 id="conceptos-clave-del-operador-de-secretos-externos">Conceptos Clave del Operador de Secretos Externos</h5>
<p>Vamos a explorar algunos conceptos fundamentales para nuestro trabajo con el Operador de Secretos Externos (ESO).</p>
<h5 id="secretstore">SecretStore</h5>
<p>SecretStore es un recurso que separa las preocupaciones de autenticación/acceso de los secretos y configuraciones necesarios para las cargas de trabajo. Este recurso está basado en espacios de nombres (namespaces).</p>
<p>Imagina SecretStore como un administrador de secretos que conoce la forma de acceder a los datos. Contiene referencias a secretos que almacenan las credenciales para acceder a la API externa.</p>
<p>Aquí tienes un ejemplo simplificado de cómo se define SecretStore:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">SecretStore</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">secretstore-sample</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">provider:</span>
    <span class="hljs-attr">aws:</span>
      <span class="hljs-attr">service:</span> <span class="hljs-string">SecretsManager</span>
      <span class="hljs-attr">region:</span> <span class="hljs-string">us-east-1</span>
      <span class="hljs-attr">auth:</span>
        <span class="hljs-attr">secretRef:</span>
          <span class="hljs-attr">accessKeyIDSecretRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">awssm-secret</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">access-key</span>
          <span class="hljs-attr">secretAccessKeySecretRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">awssm-secret</span>
            <span class="hljs-attr">key:</span> <span class="hljs-string">secret-access-key</span>
</code></pre>
<h5 id="externalsecret">ExternalSecret</h5>
<p>Un ExternalSecret declara qué datos buscar y tiene una referencia al SecretStore, que sabe cómo acceder a esos datos. El controlador utiliza este ExternalSecret como un plan para crear secretos.</p>
<p>Piensa en un ExternalSecret como una solicitud hecha al gestor de secretos (SecretStore) para buscar un secreto específico. La configuración del ExternalSecret define qué buscar, dónde buscar y cómo formatear el secreto.</p>
<p>Aquí hay un ejemplo simplificado de cómo se define el ExternalSecret:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ExternalSecret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">example</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">refreshInterval:</span> <span class="hljs-string">1h</span>
  <span class="hljs-attr">secretStoreRef:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">secretstore-sample</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">SecretStore</span>
  <span class="hljs-attr">target:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">secret-to-be-created</span>
    <span class="hljs-attr">creationPolicy:</span> <span class="hljs-string">Owner</span>
  <span class="hljs-attr">data:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">secretKey:</span> <span class="hljs-string">secret-key-to-be-managed</span>
    <span class="hljs-attr">remoteRef:</span>
      <span class="hljs-attr">key:</span> <span class="hljs-string">provider-key</span>
      <span class="hljs-attr">version:</span> <span class="hljs-string">provider-key-version</span>
      <span class="hljs-attr">property:</span> <span class="hljs-string">provider-key-property</span>
  <span class="hljs-attr">dataFrom:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">extract:</span>
      <span class="hljs-attr">key:</span> <span class="hljs-string">remote-key-in-the-provider</span>
</code></pre>
<h5 id="clustersecretstore">ClusterSecretStore</h5>
<p>El ClusterSecretStore es un SecretStore global, que puede ser referenciado por todos los namespaces. Puedes usarlo para proporcionar una puerta de acceso central a tu proveedor de secretos. Es como un SecretStore, pero con alcance en todo el cluster, en lugar de solo un namespace.</p>
<h5 id="control-de-acceso-y-seguridad">Control de Acceso y Seguridad</h5>
<p>El ESO es un operador poderoso con acceso elevado. Crea/lee/actualiza secretos en todos los namespaces y tiene acceso a secretos almacenados en algunas APIs externas. Por lo tanto, es vital asegurar que el ESO tenga solo los privilegios mínimos necesarios y que el SecretStore/ClusterSecretStore sea diseñado cuidadosamente.</p>
<p>Además, considera la utilización del sistema de control de admisión de Kubernetes (como OPA o Kyverno) para un control de acceso más refinado.</p>
<p>Ahora que tenemos una buena comprensión de los conceptos clave, vamos a proceder con la instalación del ESO en Kubernetes.</p>
<h4 id="configurando-el-external-secrets-operator">Configurando el External Secrets Operator</h4>
<p>Vamos a echar un vistazo a cómo instalar y configurar el External Secrets Operator en Kubernetes.
En este ejemplo, vamos a utilizar el ESO para que Kubernetes pueda acceder a los secretos que están en un cluster Vault.</p>
<p>Antes de comenzar, vamos a entender qué es Vault, en caso de que aún no lo conozcas.</p>
<h5 id="¿qué-es-vault">¿Qué es Vault?</h5>
<p>HashiCorp Vault es una herramienta para gestionar secretos de manera segura. Te permite almacenar y controlar el acceso a tokens, contraseñas, certificados, claves de cifrado y otra información sensible. En nuestro contexto, Vault se convierte en una solución poderosa para superar los problemas inherentes a la manera en que Kubernetes maneja los Secrets.</p>
<h5 id="¿por-qué-usar-vault">¿Por Qué Usar Vault?</h5>
<p>Con Vault, puedes centralizar la gestión de secretos, reduciendo la superficie de ataque y minimizando el riesgo de fuga de datos. Vault también ofrece control detallado de políticas de acceso, permitiendo determinar quién puede acceder a qué, cuándo y dónde.</p>
<h5 id="comandos-básicos-de-vault">Comandos Básicos de Vault</h5>
<p>Vault puede ser un poco complejo para los principiantes, pero si ya has trabajado con él, los comandos básicos son relativamente simples.</p>
<p><strong>Instalando el Hashicorp Vault</strong></p>
<pre><code class="lang-bash">wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com <span class="hljs-subst">$(lsb_release -cs)</span> main&quot;</span> | sudo tee /etc/apt/sources.list.d/hashicorp.list

sudo apt update &amp;&amp; sudo apt install vault
</code></pre>
<p><strong>Iniciando el Vault en Modo Dev</strong></p>
<pre><code class="lang-bash">vault server -dev
</code></pre>
<p>Este comando inicia Vault en modo de desarrollo, que es útil para fines de aprendizaje y experimentación.</p>
<p><strong>Configurando el Ambiente</strong></p>
<pre><code class="lang-bash"><span class="hljs-built_in">export</span> VAULT_ADDR=<span class="hljs-string">&apos;http://127.0.0.1:8200&apos;</span>
</code></pre>
<p>Esto establece la variable de entorno <code>VAULT_ADDR</code>, apuntando hacia la dirección del servidor Vault.</p>
<p><strong>Escribiendo Secrets</strong></p>
<pre><code class="lang-bash">vault kv put secret/my-secret password=my-password
</code></pre>
<p>Este comando escribe un secreto llamado <code>my-secret</code> con la contraseña <code>my-password</code>.</p>
<p><strong>Leyendo Secrets</strong></p>
<pre><code class="lang-bash">vault kv get secret/my-secret
</code></pre>
<p>Este comando lee el secreto llamado <code>my-secret</code>.</p>
<h5 id="el-vault-en-el-contexto-de-kubernetes">El Vault en el Contexto de Kubernetes</h5>
<p>Ahora que ha recordado lo básico de Vault, el siguiente paso es comprender cómo puede trabajar en conjunto con Kubernetes y ESO para mejorar la gestión de secretos.</p>
<h5 id="instalación-y-configuración-de-vault-en-kubernetes">Instalación y Configuración de Vault en Kubernetes</h5>
<p>Ahora, vamos a sumergirnos en la parte práctica. Configuraremos Vault en Kubernetes, paso a paso, utilizando Helm. Al final de este proceso, tendremos Vault instalado, configurado y listo para usar.</p>
<h5 id="requisitos-previos">Requisitos Previos</h5>
<p>Antes de comenzar, asegúrese de tener lo siguiente:</p>
<ol>
<li>Una instancia de Kubernetes en funcionamiento.</li>
<li>Helm instalado en su máquina local o en su clúster.</li>
</ol>
<h5 id="instalando-y-configurando-vault-con-helm">Instalando y Configurando Vault con Helm</h5>
<p>Aquí están los pasos para instalar y configurar Vault utilizando Helm:</p>
<p><strong>1. Agregue el repositorio de HashiCorp a Helm.</strong></p>
<pre><code class="lang-bash">helm repo add hashicorp https://helm.releases.hashicorp.com
</code></pre>
<p>Este comando agrega el repositorio Helm de HashiCorp a nuestra configuración de Helm.</p>
<p><strong>2. Instale Vault utilizando Helm</strong></p>
<pre><code class="lang-bash">helm install vault hashicorp/vault
</code></pre>
<p>Este comando instala Vault en el clúster Kubernetes.</p>
<p><strong>3. Inicie una shell interactiva dentro del pod de Vault</strong></p>
<pre><code class="lang-bash">kubectl <span class="hljs-built_in">exec</span> -ti vault-0 -- sh
</code></pre>
<p>Este comando inicia una shell interactiva dentro del pod de Vault, lo que permite interactuar directamente con Vault.</p>
<p><strong>4. Inicialice y desbloquee Vault</strong></p>
<p>En este punto, es importante que guarde las claves que se generan cuando inicializa su clúster de Vault, ya que serán necesarias para desbloquear Vault. Almacene esta información en un lugar seguro, ya que sin estas claves no podrá desbloquear Vault.</p>
<pre><code class="lang-bash">vault operator init
vault operator unseal
vault login
</code></pre>
<p>Estos comandos inicializan Vault, quitan el sello y realizan el inicio de sesión.</p>
<p><strong>5. Cree una política en Vault</strong></p>
<pre><code class="lang-bash">vault policy write external-secret-operator-policy -&lt;&lt;<span class="hljs-string">EOF
path &quot;data/postgres&quot; { 
capabilities = [&quot;read&quot;]
}
EOF</span>
</code></pre>
<p>Este comando crea una política llamada &quot;external-secret-operator-policy&quot; que otorga permisos de lectura en la ruta &quot;data/postgres&quot;.</p>
<p><strong>6. Cree un token con la política que acaba de definir</strong></p>
<pre><code class="lang-bash">vault token create -policy=<span class="hljs-string">&quot;external-secret-operator-policy&quot;</span>
</code></pre>
<p>Este comando crea un token vinculado a la política &quot;external-secret-operator-policy&quot;.</p>
<p><strong>7. Habilite el almacenamiento de secretos y agregue algunos secretos para realizar pruebas</strong></p>
<pre><code class="lang-bash">vault secrets <span class="hljs-built_in">enable</span> -path=data kv
vault kv put data/postgres POSTGRES_USER=admin POSTGRES_PASSWORD=123456
</code></pre>
<p>Estos comandos habilitan el almacenamiento de secretos y agregan un secreto de ejemplo a la ruta &quot;data/postgres&quot;.</p>
<p>¡Y eso es todo! Ahora tiene Vault instalado y configurado en su clúster Kubernetes.</p>
<h5 id="agregar-el-repositorio-del-operador-de-secretos-externos-a-helm">Agregar el Repositorio del Operador de Secretos Externos a Helm</h5>
<p>Antes de instalar ESO, necesitamos agregar el repositorio de External Secrets a Helm. Hágalo con los siguientes comandos:</p>
<pre><code class="lang-bash">helm repo add external-secrets https://charts.external-secrets.io
helm repo update
</code></pre>
<h5 id="instalando-el-operador-de-secretos-externos">Instalando el Operador de Secretos Externos</h5>
<p>Después de agregar el repositorio, puede instalar ESO con el siguiente comando:</p>
<pre><code class="lang-bash">helm install external-secrets external-secrets/external-secrets -n external-secrets --create-namespace --<span class="hljs-built_in">set</span> installCRDs=<span class="hljs-literal">true</span>
</code></pre>
<h5 id="verificación-de-la-instalación-de-eso">Verificación de la Instalación de ESO</h5>
<p>Para comprobar si ESO se ha instalado correctamente, puede ejecutar el siguiente comando:</p>
<pre><code class="lang-bash">kubectl get all -n external-secrets
</code></pre>
<h5 id="creación-de-un-secreto-en-kubernetes">Creación de un Secreto en Kubernetes</h5>
<p>Ahora, necesitamos crear un secreto en Kubernetes que contenga el token de Vault. Hágalo con el siguiente comando:</p>
<pre><code class="lang-bash">kubectl create secret generic vault-token --from-literal=token=SU_TOKEN_DE_VAULT
</code></pre>
<p>Recuerde reemplazar <code>SU_TOKEN_DE_VAULT</code> por el token real que obtuvo de Vault.</p>
<p>Para verificar si el secreto se ha creado correctamente, puede ejecutar el siguiente comando:</p>
<pre><code class="lang-bash">kubectl get secrets
</code></pre>
<h5 id="configuración-del-clustersecretstore">Configuración del ClusterSecretStore</h5>
<p>El siguiente paso es configurar el ClusterSecretStore, que es el recurso que proporcionará una pasarela central para su proveedor de secrets. Para hacerlo, debe crear un archivo llamado <code>cluster-store.yaml</code> con el siguiente contenido:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterSecretStore</span> <span class="hljs-comment">#Kubernetes resource type</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">vault-backend</span> <span class="hljs-comment">#resource name</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">provider:</span>
    <span class="hljs-attr">vault:</span> <span class="hljs-comment">#specifies vault as the provider</span>
      <span class="hljs-attr">server:</span> <span class="hljs-string">&quot;http://10.43.238.17:8200&quot;</span> <span class="hljs-comment">#the address of your vault instance</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;data&quot;</span> <span class="hljs-comment">#path for accessing the secrets</span>
      <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;v1&quot;</span> <span class="hljs-comment">#Vault API version</span>
      <span class="hljs-attr">auth:</span>
        <span class="hljs-attr">tokenSecretRef:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;vault-token&quot;</span> <span class="hljs-comment">#Use a secret called vault-token</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;token&quot;</span> <span class="hljs-comment">#Use this key to access the vault token</span>
</code></pre>
<p>Para aplicar esta configuración en Kubernetes, utilice el siguiente comando:</p>
<pre><code class="lang-bash">kubectl apply -f cluster-store.yaml
</code></pre>
<h5 id="creación-de-un-externalsecret">Creación de un ExternalSecret</h5>
<p>Finalmente, necesitamos crear un ExternalSecret que especifica qué datos buscar en el proveedor de secretos. Para hacerlo, cree un archivo llamado <code>ex-secrets.yaml</code> con el siguiente contenido:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ExternalSecret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">external-secret</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">refreshInterval:</span> <span class="hljs-string">&quot;15s&quot;</span>
  <span class="hljs-attr">secretStoreRef:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">vault-backend</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterSecretStore</span>
  <span class="hljs-attr">target:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">postgres-secret</span>
    <span class="hljs-attr">creationPolicy:</span> <span class="hljs-string">Owner</span>
  <span class="hljs-attr">data:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">secretKey:</span> <span class="hljs-string">POSTGRES_USER</span>
      <span class="hljs-attr">remoteRef:</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">data/postgres</span>
        <span class="hljs-attr">property:</span> <span class="hljs-string">POSTGRES_USER</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">secretKey:</span> <span class="hljs-string">POSTGRES_PASSWORD</span>
      <span class="hljs-attr">remoteRef:</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">data/postgres</span>
        <span class="hljs-attr">property:</span> <span class="hljs-string">POSTGRES_PASSWORD</span>
</code></pre>
<p>Para aplicar esta configuración en Kubernetes, utilice el siguiente comando:</p>
<pre><code class="lang-bash">kubectl apply -f ex-secrets.yaml
</code></pre>
<p>Para verificar la creación del ExternalSecret, puede ejecutar el siguiente comando:</p>
<pre><code class="lang-bash">kubectl get externalsecret
</code></pre>
<p>Eso es todo. Ha instalado y configurado con éxito el Operador de Secretos Externos en Kubernetes. Recuerde, este es solo un ejemplo de cómo usar ESO para integrar Vault con Kubernetes, pero los mismos principios se aplican a otros proveedores de secretos.</p>
<p>Excelente. Para verificar si la sincronización funcionó correctamente y para usar el secreto en su clúster Kubernetes, puede crear un deployment. Haremos esto creando un archivo <code>deployment.yaml</code> que define un deployment de ejemplo. En el siguiente ejemplo, crearemos un deployment de una base de datos PostgreSQL que utiliza el secreto que creamos anteriormente.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">postgres-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">postgres</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">postgres</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">postgres</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:latest</span>
        <span class="hljs-attr">env:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POSTGRES_USER</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">postgres-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">POSTGRES_USER</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POSTGRES_PASSWORD</span>
          <span class="hljs-attr">valueFrom:</span>
            <span class="hljs-attr">secretKeyRef:</span>
              <span class="hljs-attr">name:</span> <span class="hljs-string">postgres-secret</span>
              <span class="hljs-attr">key:</span> <span class="hljs-string">POSTGRES_PASSWORD</span>
</code></pre>
<p>Este archivo define un deployment de PostgreSQL con una única réplica. Establece dos variables de entorno, <code>POSTGRES_USER</code> y <code>POSTGRES_PASSWORD</code>, que obtienen sus valores del secreto <code>postgres-secret</code> que creamos previamente utilizando el Operador de Secretos Externos.</p>
<p>Para crear el deployment, utilice el siguiente comando:</p>
<pre><code class="lang-bash">kubectl apply -f deployment.yaml
</code></pre>
<p>Después de ejecutar este comando, Kubernetes creará el deployment e iniciará el contenedor de PostgreSQL. Los valores de <code>POSTGRES_USER</code> y <code>POSTGRES_PASSWORD</code> se llenarán con los valores del secreto <code>postgres-secret</code>.</p>
<p>Para verificar si el deployment se creó con éxito, puede ejecutar el siguiente comando:</p>
<pre><code class="lang-bash">kubectl get deployment
</code></pre>
<h2 id="final-del-día-8">Final del Día 8</h2>
<p>Hoy dedicamos el día a dos componentes importantes de Kubernetes: Secrets y ConfigMaps.</p>
<p>En Kubernetes, los Secrets son un recurso que nos permite gestionar información sensible, como contraseñas, tokens OAuth, claves SSH, etc. Debido a su naturaleza sensible, Kubernetes ofrece una serie de características para gestionar los Secrets de manera segura. Aprendimos cómo crear, obtener y describir un Secret, así como cómo eliminarlo. Fuimos un paso más allá al usar un Secret para almacenar un certificado TLS y una clave privada, que luego utilizamos para configurar Nginx para usar HTTPS. Montamos el certificado TLS y la clave privada en un Pod de Nginx utilizando un archivo de manifiesto para definir el Secret.</p>
<p>Luego, exploramos ConfigMaps. Los ConfigMaps son una forma eficiente de separar los parámetros de configuración de las imágenes de los contenedores, lo que permite que una misma imagen de contenedor se ejecute en diferentes entornos, como desarrollo, pruebas y producción, con configuraciones diferentes. Aprendimos a actualizar un ConfigMap, cómo usarlo y cómo definir variables de entorno para los contenedores en un Pod utilizando ConfigMaps. También vimos cómo hacer que los ConfigMaps sean inmutables.</p>
<p>Creamos un archivo de configuración de Nginx utilizando un ConfigMap, que luego utilizamos para configurar un Pod de Nginx. Exploramos cómo montar el ConfigMap en un volumen y cómo utilizar un archivo de manifiesto para definir el ConfigMap.</p>
<p>Además, simplificamos el uso del Operador de Secretos Externos y su integración con Vault.</p>
<p>Finalmente, combinamos ConfigMaps y Secrets para configurar un Pod de Nginx para utilizar HTTPS. Utilizamos el ConfigMap para almacenar el archivo de configuración de Nginx y el Secret para almacenar el certificado TLS y la clave privada.</p>
<p>Esta combinación de ConfigMaps y Secrets nos permite gestionar eficientemente nuestras configuraciones y datos sensibles de manera segura, al tiempo que nos brinda un alto grado de flexibilidad y control sobre nuestras aplicaciones.</p>
<p>¡Y eso es todo por hoy! Nos vemos en el próximo día. ¡Hasta entonces!   :wave:   :v:</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../day-7/" class="navigation navigation-prev " aria-label="Previous page: Simplificando Kubernetes día 7">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../day-9/" class="navigation navigation-next " aria-label="Next page: Simplificando Kubernetes día 9">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Simplificando Kubernetes día 8","level":"2.8","depth":1,"next":{"title":"Simplificando Kubernetes día 9","level":"2.9","depth":1,"path":"day-9/README.md","ref":"day-9/README.md","articles":[]},"previous":{"title":"Simplificando Kubernetes día 7","level":"2.7","depth":1,"path":"day-7/README.md","ref":"day-7/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"day-8/README.md","mtime":"2024-06-29T09:22:11.969Z","type":"markdown"},"gitbook":{"version":"3.6.20","time":"2024-06-29T09:22:22.563Z"},"basePath":"..","book":{"language":"es"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

